"""
Visualization helpers for community-level and node-level flow fingerprints.

Input: sbm/output/sbm_graphtool_membership.csv (generated by sbm_v2.extract_results)

Outputs: PNG files saved under sbm/visualization/flowdirection:
1) Community-level 2x2 heatmaps of average outflow patterns per layer
2) Node-level heatmaps for every community (4 layers each, one figure per community)
3) Optional per-node line plots comparing flow spectra across target communities

Usage:
    python flow_profiles_viz.py \
        --membership_csv sbm/output/sbm_graphtool_membership.csv \
        --output_dir sbm/visualization/flowdirection \
        --focus-nodes 8.2_Pos 9.2_Pos 11.1_Pos

Args:
    --membership_csv: Path to membership CSV (required)
    --output_dir: Directory to save figures (default: sbm/visualization/flowdirection)
    --focus-nodes: Nodes to compare via line plots (optional; layer 0 by default)
"""

import argparse
from pathlib import Path
from typing import List

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

# Layer label map to keep captions compact
LAYER_LABELS = {
    0: "Pos→Pos",
    1: "Neg→Neg",
    2: "Pos→Neg",
    3: "Neg→Pos",
}


def load_membership(csv_path: Path) -> pd.DataFrame:
    if not csv_path.exists():
        raise FileNotFoundError(f"Membership CSV not found: {csv_path}")
    df = pd.read_csv(csv_path)
    expected_cols = {"node", "community"}
    missing = expected_cols - set(df.columns)
    if missing:
        raise ValueError(f"Missing required columns: {missing}")
    return df


def plot_community_heatmaps(df: pd.DataFrame, output_dir: Path) -> None:
    """Plot 2x2 community-level heatmaps: source community × target community for each layer."""
    num_comms = df["community"].nunique()
    fig, axes = plt.subplots(2, 2, figsize=(10, 8), constrained_layout=True)
    axes = axes.flatten()

    for layer in range(4):
        cols = [f"flow_layer{layer}_toC{k}" for k in range(1, num_comms + 1)]
        layer_matrix = df.groupby("community")[cols].mean().values  # (num_comms, num_comms)
        ax = axes[layer]
        im = ax.imshow(layer_matrix, aspect="auto", cmap="magma")
        ax.set_title(LAYER_LABELS[layer])
        ax.set_xlabel("Target community")
        ax.set_ylabel("Source community")
        ax.set_xticks(range(num_comms))
        ax.set_xticklabels([f"C{k}" for k in range(1, num_comms + 1)], rotation=45)
        ax.set_yticks(range(num_comms))
        ax.set_yticklabels([f"C{k}" for k in range(1, num_comms + 1)])
        fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04, label="Avg flow share")

    fig.suptitle("Community-level flow fingerprints (avg over nodes)", fontsize=14)
    fig.savefig(output_dir / "community_flow_heatmaps.png", dpi=300)
    plt.close(fig)


def plot_node_heatmap(df: pd.DataFrame, community: int, layers: List[int], output_dir: Path) -> None:
    """
    For a given community, plot node × target-community heatmaps for selected layers.
    Nodes are sorted by total_degree to surface core nodes at the top.
    """
    num_comms = df["community"].nunique()
    sub = df[df["community"] == community].copy()
    if sub.empty:
        raise ValueError(f"No nodes found for community {community}")
    sub = sub.sort_values("total_degree", ascending=False)

    n_layers = len(layers)
    # Slightly taller, less wide per user request
    if n_layers == 4:
        fig, axes = plt.subplots(2, 2, figsize=(9, max(5, len(sub) * 0.3)), constrained_layout=True)
        axes = axes.flatten()
    else:
        fig, axes = plt.subplots(1, n_layers, figsize=(5.5 * n_layers, max(5, len(sub) * 0.3)), squeeze=False)
        axes = axes[0]

    for ax, layer in zip(axes, layers):
        cols = [f"flow_layer{layer}_toC{k}" for k in range(1, num_comms + 1)]
        data = sub[cols].values
        im = ax.imshow(data, aspect="auto", cmap="magma")
        ax.set_title(f"C{community}: {LAYER_LABELS[layer]}")
        ax.set_xlabel("Target community")
        ax.set_xticks(range(num_comms))
        ax.set_xticklabels([f"C{k}" for k in range(1, num_comms + 1)], rotation=45)
        ax.set_yticks(range(len(sub)))
        ax.set_yticklabels(sub["node"].tolist(), fontsize=7)
        fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04, label="Flow share")

    fig.suptitle(f"Node-level flow patterns in community C{community}", fontsize=14)
    fig.savefig(output_dir / f"community_C{community}_node_flow_heatmaps.png", dpi=300)
    plt.close(fig)


def plot_focus_nodes(df: pd.DataFrame, focus_nodes: List[str], output_dir: Path, layer: int = 0) -> None:
    """Line plot comparing flow spectra for specific nodes across target communities."""
    if not focus_nodes:
        return
    num_comms = df["community"].nunique()
    x = list(range(1, num_comms + 1))
    xticks = [f"C{k}" for k in x]
    fig = plt.figure(figsize=(7, 4))

    cols = [f"flow_layer{layer}_toC{k}" for k in x]
    for node in focus_nodes:
        row = df[df["node"] == node]
        if row.empty:
            print(f"[warn] Node not found: {node}")
            continue
        y = row.iloc[0][cols].values
        plt.plot(x, y, marker="o", label=node)

    plt.xticks(x, xticks)
    plt.xlabel("Target community")
    plt.ylabel(f"{LAYER_LABELS[layer]} flow share")
    plt.title(f"Flow spectra per node ({LAYER_LABELS[layer]})")
    plt.legend()
    plt.tight_layout()
    sanitized = "_".join([n.replace("/", "-") for n in focus_nodes]) or "focus_nodes"
    fig.savefig(output_dir / f"focus_nodes_layer{layer}_{sanitized}.png", dpi=300)
    plt.close(fig)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Visualize flow fingerprints from sbm_graphtool_membership.csv")
    parser.add_argument("--membership_csv", type=Path, default=Path("output/sbm_graphtool_membership.csv"))
    parser.add_argument("--output_dir", type=Path, default=Path("visualization/flowdirection"))
    parser.add_argument("--focus-nodes", nargs="*", default=[], help="Nodes to plot spectra for (optional)")
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    df = load_membership(args.membership_csv)
    args.output_dir.mkdir(parents=True, exist_ok=True)

    print(f"Loaded membership: {len(df)} nodes, {df['community'].nunique()} communities")
    print(f"Plotting community-level heatmaps...")
    plot_community_heatmaps(df, args.output_dir)

    print("Plotting node-level heatmaps for every community (all 4 layers each)...")
    for comm in sorted(df["community"].unique()):
        plot_node_heatmap(df, comm, layers=[0, 1, 2, 3], output_dir=args.output_dir)

    if args.focus_nodes:
        print("Plotting focus nodes spectra for layer 0 (Pos→Pos) by default")
        plot_focus_nodes(df, args.focus_nodes, output_dir=args.output_dir, layer=0)


if __name__ == "__main__":
    main()
